1.在启动代码中修改堆栈的大小 

Stack_Size        EQU   0x400 //栈大小 1024byte

Heap_Size   EQU   0x200 //堆大小 512byte



2.堆栈分析

2.1堆栈的溢出

若局部变量较多、定义的数据长度，加一起的空间大于**栈（Stack）**的空间，则会导致栈溢出，程序运行结果与预期的不符

或程序跑飞。这时需要手动的调整栈的大小，来复合我们的需求.

若使用了malloc动态分配内存空间时，大于设置的**堆（Heap）**的空间。会导致溢出，需要调整堆的大小

1.2.2、堆栈的增长方向

一般**堆是由低地址往上（高地址）增长**，**栈是由高地址向下（低地址）增长**。都是连续的，

C语言不提供内存保护机制类似的功能，如果一直堆一直增长，栈一直申请，然后就会导致栈溢出，程序崩溃

1.2.3、堆栈的首地址

一般 的，内存首先存放/开辟全局变量区域，然后开辟栈区最后开辟堆区

**栈首地址****=****全局区域大小****+****栈大小（****Stack_Size****）**

**1.2.4****、堆栈的区别**

存储的内容：栈存局部变量、函数参数等

​          堆存储使用 new、malloc 申请 的变量等

申请的方式：栈内存由系统分配、释放

​          堆内存由自己申请、释放

申请后系统的响应：（带操作系统的环境）

栈——只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出

堆——首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申 请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空 闲结点链表 中删除，并将该结点的空间分配给程序

申请大小的限制：单片机一般堆栈大小都是固定，有操作系统情况下，堆的大小可以随意增长，收到硬件的显示

申请效率的对比：栈由系统自动分配，速度较快

​              堆使用 new、malloc 等分配，较慢

2.1、内存四区和内存五区的区别

其实内存四区和内存五区所指的东西是一样的，对于内存四区而言，其只是把全局区(静态区)和常量区合并为一个数据区而已，其实内容都是完全一样的

 

2.1.1、内存四区

栈区、堆区、数据区（全局区(静态区)、常量区）、代码区

 

2.1.2、内存五区

栈区、堆区、全局区(静态区)、常量区、代码区

 

2.2、内存四区具体含义

2.2.1、栈区

系统自动分配，函数结束自动释放，也可以说由编译器自动分配和释放

局部变量、局部常量、函数参数

特点：进栈出栈有相应的计算机指令支持，而且分配专门的寄存器存储栈的地址，效率分高，内存空间是连续的，但栈的内存空间有限

2.2.2、堆区

使用malloc()/new()申请的内容存储在堆区

由程序员手动分配，手动释放，或者程序结束系统回收，不释放就会产生内存泄漏

2.2.3、全局区（静态区）

全局变量、静态变量（全局or局部）

全局区分为两个段：

data段：存储初始化的全局变量、初始化的静态变量

bss段：存储未初始化的全局变量、未初始化的静态变量

调用函数结束不会被销毁

其中BSS段会在程序执行前**，将内容全部置为0，**所以未初始化的全局变量和静态变量的值都为0

2.2.4、常量区

- 存放常量，字符串常量和其他常量的存储位置，而且不允许修改
- 程序结束之后由系统释放

2.2.5、代码区

- 要存放程序中的代码（二进制），属性是只读
- 又称text段

 

来自 <https://blog.csdn.net/daizhifeng123468/article/details/129304407> 



malloc函数分配空间，free()之后要重新赋值，才不会出现00的现象。

malloc函数分配的内存大小计算可以通过 size_t sizeof() 表达式计算